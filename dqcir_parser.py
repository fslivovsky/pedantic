#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
DQCIR Parser for DQBF (Dependency Quantified Boolean Formulas)

This parser handles the DQCIR format where:
- Variables are introduced via forall(...) and exists(...) blocks
- Dependencies are specified via depend(var, dep1, dep2, ...) lines
- Gates include and, or, xor operations
- The output gate is specified via output(...)
"""

from counter import Counter


class DQCIRParser:
  """Parser for DQBF in DQCIR format."""
  
  def __init__(self, counter=None):
    """Initialize the DQCIR parser.
    
    Args:
      counter: Optional Counter object to use for ID generation.
          If None, a new Counter starting at 0 is created.
    """
    self.counter = counter if counter is not None else Counter(0)
    
    # Mapping from variable/gate names to integer IDs
    self.name_to_id = {}
    
    # Mapping from integer IDs to variable/gate names
    self.id_to_name = {}
    
    # Set of universally quantified variables
    self.forall_vars = set()
    
    # Set of existentially quantified variables
    self.exists_vars = set()
    
    # Dictionary mapping existential variables to their dependencies
    # Key: existential variable name, Value: list of universal variables it depends on
    self.dependencies = {}
    
    # Dictionary mapping gate IDs to their type and inputs
    # Key: gate ID, Value: dict with 'type' (and/or/xor) and 'inputs' (list of IDs)
    self.gates = {}
    
    # Output gate name
    self.output_gate = None
    
    # List of all forall variables in order of introduction
    self.forall_vars_ordered = []
    
    # CNF clauses generated by Tseitin transformation
    self.cnf = []
    
    # Auxiliary variables created during Tseitin transformation
    self.aux_vars = set()
  
  def _get_or_create_id(self, name):
    """Get existing ID for a name, or create a new one."""
    if name not in self.name_to_id:
      new_id = self.counter.increase()
      self.name_to_id[name] = new_id
      self.id_to_name[new_id] = name
    return self.name_to_id[name]
  
  def _parse_literal(self, literal):
    """Parse a literal (possibly negated variable/gate) and return (id, negated).
    
    Args:
      literal: String like "x", "-x", "gate1", "-gate2"
      
    Returns:
      tuple: (id, is_negated) where id is the integer ID and is_negated is bool
    """
    literal = literal.strip()
    if literal.startswith('-'):
      return (self._get_or_create_id(literal[1:]), True)
    else:
      return (self._get_or_create_id(literal), False)
  
  def parse_file(self, filename):
    """Parse a DQCIR file.
    
    Args:
      filename: Path to the DQCIR file
    """
    with open(filename, 'r') as f:
      for line in f:
        line = line.strip()
        
        # Skip empty lines and comments
        if not line or line.startswith('#'):
          continue
        
        self._parse_line(line)
  
  def _parse_line(self, line):
    """Parse a single line of DQCIR format."""
    
    # Parse forall quantifier
    if line.startswith('forall('):
      self._parse_forall(line)
    
    # Parse exists quantifier
    elif line.startswith('exists('):
      self._parse_exists(line)
    
    # Parse dependency declaration
    elif line.startswith('depend('):
      self._parse_depend(line)
    
    # Parse output declaration
    elif line.startswith('output('):
      self._parse_output(line)
    
    # Parse gate definitions
    elif '=' in line:
      self._parse_gate(line)
  
  def _parse_forall(self, line):
    """Parse a forall(...) line."""
    # Extract variables between parentheses
    start = line.index('(') + 1
    end = line.rindex(')')
    vars_str = line[start:end]
    
    # Split by comma and process each variable
    for var in vars_str.split(','):
      var = var.strip()
      if var:
        self._get_or_create_id(var)
        self.forall_vars.add(var)
        self.forall_vars_ordered.append(var)
  
  def _parse_exists(self, line):
    """Parse an exists(...) line."""
    # Extract variables between parentheses
    start = line.index('(') + 1
    end = line.rindex(')')
    vars_str = line[start:end]
    
    # Split by comma and process each variable
    exists_vars = []
    for var in vars_str.split(','):
      var = var.strip()
      if var:
        self._get_or_create_id(var)
        self.exists_vars.add(var)
        exists_vars.append(var)
    
    # Each existential variable in exists block depends on all forall vars seen so far
    for var in exists_vars:
      if var not in self.dependencies:
        self.dependencies[var] = list(self.forall_vars_ordered)
  
  def _parse_depend(self, line):
    """Parse a depend(var, dep1, dep2, ...) line."""
    # Extract content between parentheses
    start = line.index('(') + 1
    end = line.rindex(')')
    content = line[start:end]
    
    # Split by comma
    parts = [p.strip() for p in content.split(',')]
    
    if len(parts) < 1:
      return
    
    # First part is the existential variable
    exist_var = parts[0]
    self._get_or_create_id(exist_var)
    self.exists_vars.add(exist_var)
    
    # Remaining parts are the dependencies (universal variables)
    deps = parts[1:]
    self.dependencies[exist_var] = [d for d in deps if d]
    
    # Ensure all dependencies have IDs
    for dep in self.dependencies[exist_var]:
      self._get_or_create_id(dep)
  
  def _parse_output(self, line):
    """Parse an output(...) line."""
    start = line.index('(') + 1
    end = line.rindex(')')
    self.output_gate = line[start:end].strip()
    self._get_or_create_id(self.output_gate)
  
  def _parse_gate(self, line):
    """Parse a gate definition line like: gate_name = and(input1, input2, ...)"""
    # Split by '='
    parts = line.split('=', 1)
    if len(parts) != 2:
      return
    
    gate_name = parts[0].strip()
    gate_def = parts[1].strip()
    
    # Convert to lowercase for case-insensitive matching
    gate_def_lower = gate_def.lower()
    
    # Determine gate type
    gate_type = None
    if gate_def_lower.startswith('and('):
      gate_type = 'and'
    elif gate_def_lower.startswith('or('):
      gate_type = 'or'
    elif gate_def_lower.startswith('xor('):
      gate_type = 'xor'
    else:
      return
    
    # Extract inputs
    start = gate_def.index('(') + 1
    end = gate_def.rindex(')')
    inputs_str = gate_def[start:end]
    
    # Parse inputs (can be negated)
    inputs = []
    for inp in inputs_str.split(','):
      inp = inp.strip()
      if inp:
        inp_id, is_negated = self._parse_literal(inp)
        inputs.append((inp_id, is_negated))
    
    # Get or create ID for this gate
    gate_id = self._get_or_create_id(gate_name)
    
    # Store gate information
    self.gates[gate_id] = {
      'type': gate_type,
      'inputs': inputs
    }
  
  def get_gate_info(self, gate_id):
    """Get information about a gate by its ID.
    
    Args:
      gate_id: Integer ID of the gate
      
    Returns:
      dict: {'type': gate_type, 'inputs': [(id, negated), ...]} or None
    """
    return self.gates.get(gate_id)
  
  def get_dependencies(self, var_name):
    """Get dependencies of an existential variable.
    
    Args:
      var_name: Name of the existential variable
      
    Returns:
      list: List of universal variable names it depends on, or None
    """
    return self.dependencies.get(var_name)
  
  def get_dependencies_by_id(self, var_id):
    """Get dependencies of an existential variable by its ID.
    
    Args:
      var_id: Integer ID of the existential variable
      
    Returns:
      list: List of universal variable IDs it depends on, or None
    """
    var_name = self.id_to_name.get(var_id)
    if var_name and var_name in self.dependencies:
      return [self.name_to_id[dep] for dep in self.dependencies[var_name]]
    return None
  
  def _create_aux_var(self, name_hint=None):
    """Create a new auxiliary variable for Tseitin transformation.
    
    Args:
      name_hint: Optional hint for naming the auxiliary variable
      
    Returns:
      int: ID of the new auxiliary variable
    """
    aux_id = self.counter.increase()
    if name_hint:
      aux_name = f"_aux_{name_hint}_{aux_id}"
    else:
      aux_name = f"_aux_{aux_id}"
    
    self.id_to_name[aux_id] = aux_name
    self.name_to_id[aux_name] = aux_id
    self.aux_vars.add(aux_id)
    
    return aux_id
  
  def tseitin_transform(self):
    """Apply Tseitin transformation to generate CNF equivalent to the circuit.
    
    Returns:
      list: CNF formula as a list of clauses, where each clause is a list of integers.
         Positive integers represent positive literals, negative integers represent
         negative literals.
    """
    self.cnf = []
    
    # Process each gate and generate Tseitin clauses
    for gate_id, gate_info in self.gates.items():
      gate_type = gate_info['type']
      inputs = gate_info['inputs']
      
      if gate_type == 'and':
        self._tseitin_and(gate_id, inputs)
      elif gate_type == 'or':
        self._tseitin_or(gate_id, inputs)
      elif gate_type == 'xor':
        self._tseitin_xor(gate_id, inputs)
    
    # Note: We do NOT add a unit clause for the output gate
    # This allows the solver to explore both satisfying and unsatisfying assignments
    
    return self.cnf
  
  def _tseitin_and(self, gate_id, inputs):
    """Generate Tseitin clauses for AND gate: gate_id <=> (input1 AND input2 AND ...)
    
    Clauses:
    1. gate_id => input1 AND input2 AND ...  (for each input: -gate_id OR input)
    2. input1 AND input2 AND ... => gate_id  (gate_id OR -input1 OR -input2 OR ...)
    
    Args:
      gate_id: ID of the gate
      inputs: List of (input_id, is_negated) tuples
    """
    # gate_id => each input
    for inp_id, is_negated in inputs:
      literal = -inp_id if is_negated else inp_id
      self.cnf.append([-gate_id, literal])
    
    # all inputs => gate_id
    clause = [gate_id]
    for inp_id, is_negated in inputs:
      literal = inp_id if is_negated else -inp_id
      clause.append(literal)
    self.cnf.append(clause)
  
  def _tseitin_or(self, gate_id, inputs):
    """Generate Tseitin clauses for OR gate: gate_id <=> (input1 OR input2 OR ...)
    
    Clauses:
    1. input1 OR input2 OR ... => gate_id  (for each input: input OR -gate_id)
    2. gate_id => input1 OR input2 OR ...  (-gate_id OR input1 OR input2 OR ...)
    
    Args:
      gate_id: ID of the gate
      inputs: List of (input_id, is_negated) tuples
    """
    # each input => gate_id
    for inp_id, is_negated in inputs:
      literal = -inp_id if is_negated else inp_id
      self.cnf.append([-literal, gate_id])
    
    # gate_id => at least one input
    clause = [-gate_id]
    for inp_id, is_negated in inputs:
      literal = -inp_id if is_negated else inp_id
      clause.append(literal)
    self.cnf.append(clause)
  
  def _tseitin_xor(self, gate_id, inputs):
    """Generate Tseitin clauses for XOR gate: gate_id <=> (input1 XOR input2 XOR ...)
    
    For XOR with more than 2 inputs, we introduce auxiliary variables that represent
    the parity of inputs up to a given position:
    aux1 = input1 XOR input2
    aux2 = aux1 XOR input3
    ...
    gate_id = auxN-2 XOR inputN
    
    Args:
      gate_id: ID of the gate
      inputs: List of (input_id, is_negated) tuples
    """
    if len(inputs) == 0:
      # XOR with no inputs is false
      self.cnf.append([-gate_id])
      return
    
    if len(inputs) == 1:
      # XOR with one input: gate_id <=> input
      inp_id, is_negated = inputs[0]
      if is_negated:
        # gate_id <=> NOT input
        self.cnf.append([-gate_id, -inp_id])
        self.cnf.append([gate_id, inp_id])
      else:
        # gate_id <=> input
        self.cnf.append([-gate_id, inp_id])
        self.cnf.append([gate_id, -inp_id])
      return
    
    if len(inputs) == 2:
      # XOR with two inputs: gate_id <=> (input1 XOR input2)
      inp1_id, is_neg1 = inputs[0]
      inp2_id, is_neg2 = inputs[1]
      
      lit1 = -inp1_id if is_neg1 else inp1_id
      lit2 = -inp2_id if is_neg2 else inp2_id
      
      self._tseitin_xor2(gate_id, lit1, lit2)
      return
    
    # XOR with more than 2 inputs: create auxiliary variables
    # Start with first two inputs
    inp1_id, is_neg1 = inputs[0]
    inp2_id, is_neg2 = inputs[1]
    
    lit1 = -inp1_id if is_neg1 else inp1_id
    lit2 = -inp2_id if is_neg2 else inp2_id
    
    # Create auxiliary variable for parity of first two inputs
    aux_id = self._create_aux_var(f"xor_{gate_id}")
    self._tseitin_xor2(aux_id, lit1, lit2)
    
    # Chain through remaining inputs
    prev_aux = aux_id
    for i in range(2, len(inputs) - 1):
      inp_id, is_negated = inputs[i]
      lit = -inp_id if is_negated else inp_id
      
      # Create new auxiliary for accumulated parity
      new_aux = self._create_aux_var(f"xor_{gate_id}_{i}")
      self._tseitin_xor2(new_aux, prev_aux, lit)
      prev_aux = new_aux
    
    # Final XOR with last input produces the gate output
    last_inp_id, last_is_neg = inputs[-1]
    last_lit = -last_inp_id if last_is_neg else last_inp_id
    self._tseitin_xor2(gate_id, prev_aux, last_lit)
  
  def _tseitin_xor2(self, out_id, lit1, lit2):
    """Generate Tseitin clauses for 2-input XOR: out_id <=> (lit1 XOR lit2)
    
    Truth table for XOR:
    lit1  lit2  out
     0     0     0
     0     1     1
     1     0     1
     1     1     0
    
    Clauses:
    1. (-out OR -lit1 OR -lit2)  # not all true
    2. (-out OR lit1 OR lit2)     # not both false when out is true
    3. (out OR -lit1 OR lit2)     # out is true when exactly one is true
    4. (out OR lit1 OR -lit2)     # out is true when exactly one is true
    
    Args:
      out_id: Output variable ID
      lit1: First input literal (can be positive or negative)
      lit2: Second input literal (can be positive or negative)
    """
    # XOR is true when inputs differ
    self.cnf.append([-out_id, -lit1, -lit2])  # If out, then not both true
    self.cnf.append([-out_id, lit1, lit2])     # If out, then not both false
    self.cnf.append([out_id, -lit1, lit2])     # If not out, then both false or both true
    self.cnf.append([out_id, lit1, -lit2])     # If not out, then both false or both true
  
  def print_summary(self, show_cnf=False):
    """Print a summary of the parsed DQCIR formula.
    
    Args:
      show_cnf: If True, also display CNF information
    """
    print("=" * 60)
    print("DQCIR Parser Summary")
    print("=" * 60)
    
    print(f"\nTotal variables/gates: {self.counter.n}")
    print(f"Universal variables: {len(self.forall_vars)}")
    print(f"Existential variables: {len(self.exists_vars)}")
    print(f"Gates: {len(self.gates)}")
    print(f"Output gate: {self.output_gate}")
    
    if self.aux_vars:
      print(f"Auxiliary variables (Tseitin): {len(self.aux_vars)}")
    
    if self.cnf:
      print(f"CNF clauses: {len(self.cnf)}")
    
    print("\n" + "-" * 60)
    print("Existential Variables and Dependencies:")
    print("-" * 60)
    for var, deps in sorted(self.dependencies.items()):
      var_id = self.name_to_id[var]
      print(f"  {var} (ID={var_id}) depends on: {', '.join(deps)}")
    
    print("\n" + "-" * 60)
    print("Sample Gates (first 10):")
    print("-" * 60)
    count = 0
    for gate_id, gate_info in sorted(self.gates.items()):
      if count >= 10:
        break
      gate_name = self.id_to_name[gate_id]
      inputs_str = []
      for inp_id, is_neg in gate_info['inputs']:
        inp_name = self.id_to_name[inp_id]
        inputs_str.append(f"{'-' if is_neg else ''}{inp_name}")
      print(f"  {gate_name} (ID={gate_id}) = {gate_info['type']}({', '.join(inputs_str)})")
      count += 1
    
    if len(self.gates) > 10:
      print(f"  ... and {len(self.gates) - 10} more gates")
    
    if show_cnf and self.cnf:
      print("\n" + "-" * 60)
      print("CNF Clauses (first 10):")
      print("-" * 60)
      for i, clause in enumerate(self.cnf[:10]):
        clause_str = ' v '.join([str(lit) for lit in clause])
        print(f"  Clause {i+1}: ({clause_str})")
      
      if len(self.cnf) > 10:
        print(f"  ... and {len(self.cnf) - 10} more clauses")


def main():
  """Example usage of the DQCIR parser."""
  import argparse
  import os
  import sys
  
  # Set up argument parser
  parser_args = argparse.ArgumentParser(
    description='Parse DQBF formulas in DQCIR format',
    formatter_class=argparse.RawDescriptionHelpFormatter,
    epilog="""
Example:
 python dqcir_parser.py formula.dqcir
 python dqcir_parser.py formula.dqcir --cnf
 python dqcir_parser.py formula.dqcir --cnf --show-cnf
    """
  )
  
  parser_args.add_argument(
    'filename',
    type=str,
    help='Path to the DQCIR file to parse'
  )
  
  parser_args.add_argument(
    '--cnf',
    action='store_true',
    help='Generate CNF using Tseitin transformation'
  )
  
  parser_args.add_argument(
    '--show-cnf',
    action='store_true',
    help='Display sample CNF clauses in summary (implies --cnf)'
  )
  
  args = parser_args.parse_args()
  
  # Check if file exists
  if not os.path.isfile(args.filename):
    print(f"Error: File '{args.filename}' does not exist.", file=sys.stderr)
    sys.exit(1)
  
  # Check if file is readable
  if not os.access(args.filename, os.R_OK):
    print(f"Error: File '{args.filename}' is not readable.", file=sys.stderr)
    sys.exit(1)
  
  # Parse the file
  parser = DQCIRParser()
  try:
    parser.parse_file(args.filename)
    
    # Generate CNF if requested
    if args.cnf or args.show_cnf:
      print("Generating CNF using Tseitin transformation...")
      cnf = parser.tseitin_transform()
      print(f"Generated {len(cnf)} clauses with {len(parser.aux_vars)} auxiliary variables.\n")
    
    parser.print_summary(show_cnf=args.show_cnf)
    
    # Example: Access gate information
    if parser.output_gate:
      output_id = parser.name_to_id[parser.output_gate]
      gate_info = parser.get_gate_info(output_id)
      if gate_info:
        print(f"\nOutput gate '{parser.output_gate}' (ID={output_id}) is of type: {gate_info['type']}")
  except Exception as e:
    print(f"Error parsing file: {e}", file=sys.stderr)
    import traceback
    traceback.print_exc()
    sys.exit(1)


if __name__ == "__main__":
  main()
